(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 4);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/* no static exports found */
/* all exports used */
/*!******************************************!*\
  !*** ./src/Components/InputComponent.ts ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Input component default implementation\n * @author Islam Attrash\n */\nvar InputComponent = /** @class */ (function () {\n    function InputComponent() {\n    }\n    InputComponent.prototype.render = function () {\n        return \"<input class=\\\"infinite-autocomplete-default-input\\\" type=\\\"text\\\" />\";\n    };\n    return InputComponent;\n}());\nexports.InputComponent = InputComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Db21wb25lbnRzL0lucHV0Q29tcG9uZW50LnRzPzUxYWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSUlucHV0Q29tcG9uZW50IH0gZnJvbSBcIi4uL0ludGVyZmFjZXMvSUlucHV0Q29tcG9uZW50XCI7XG5cbi8qKlxuICogSW5wdXQgY29tcG9uZW50IGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAqIEBhdXRob3IgSXNsYW0gQXR0cmFzaFxuICovXG5leHBvcnQgY2xhc3MgSW5wdXRDb21wb25lbnQgaW1wbGVtZW50cyBJSW5wdXRDb21wb25lbnQge1xuICBwdWJsaWMgcmVuZGVyKCkge1xuICAgICAgcmV0dXJuIGA8aW5wdXQgY2xhc3M9XCJpbmZpbml0ZS1hdXRvY29tcGxldGUtZGVmYXVsdC1pbnB1dFwiIHR5cGU9XCJ0ZXh0XCIgLz5gO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tcG9uZW50cy9JbnB1dENvbXBvbmVudC50cyJdLCJtYXBwaW5ncyI6Ijs7QUFFQTs7O0FBR0E7QUFDQTtBQUFBO0FBSUE7QUFIQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBSkE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/* no static exports found */
/* all exports used */
/*!********************************************!*\
  !*** ./src/Components/OptionsComponent.ts ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Options component default implementation\n * @author Islam Attrash\n */\nvar OptionsComponent = /** @class */ (function () {\n    function OptionsComponent() {\n        this.listElementSelector = \"ul\";\n    }\n    OptionsComponent.prototype.render = function () {\n        return \"<\" + this.listElementSelector + \" class=\\\"infinite-autocomplete-default-options\\\"></\" + this.listElementSelector + \">\";\n    };\n    OptionsComponent.prototype.renderOption = function (option) {\n        return \"<li>\\n                \" + option.text + \"\\n            </li>\";\n    };\n    return OptionsComponent;\n}());\nexports.OptionsComponent = OptionsComponent;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Db21wb25lbnRzL09wdGlvbnNDb21wb25lbnQudHM/NDNjMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJT3B0aW9uc0NvbXBvbmVudCB9IGZyb20gXCIuLi9JbnRlcmZhY2VzL0lPcHRpb25zQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBJT3B0aW9uIH0gZnJvbSBcIi4uL0ludGVyZmFjZXMvSU9wdGlvblwiO1xuXG4vKipcbiAqIE9wdGlvbnMgY29tcG9uZW50IGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAqIEBhdXRob3IgSXNsYW0gQXR0cmFzaFxuICovXG5leHBvcnQgY2xhc3MgT3B0aW9uc0NvbXBvbmVudCBpbXBsZW1lbnRzIElPcHRpb25zQ29tcG9uZW50IHtcbiAgcHVibGljIGxpc3RFbGVtZW50U2VsZWN0b3I6IHN0cmluZyA9IGB1bGA7XG5cbiAgcHVibGljIHJlbmRlcigpIHtcbiAgICByZXR1cm4gYDwke3RoaXMubGlzdEVsZW1lbnRTZWxlY3Rvcn0gY2xhc3M9XCJpbmZpbml0ZS1hdXRvY29tcGxldGUtZGVmYXVsdC1vcHRpb25zXCI+PC8ke3RoaXMubGlzdEVsZW1lbnRTZWxlY3Rvcn0+YDtcbiAgfVxuXG4gIHB1YmxpYyByZW5kZXJPcHRpb24ob3B0aW9uOiBJT3B0aW9uKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYDxsaT5cbiAgICAgICAgICAgICAgICAke29wdGlvbi50ZXh0fVxuICAgICAgICAgICAgPC9saT5gO1xuICB9XG5cbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db21wb25lbnRzL09wdGlvbnNDb21wb25lbnQudHMiXSwibWFwcGluZ3MiOiI7O0FBR0E7OztBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBWUE7QUFWQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFFQTtBQUFBO0FBYkE7Iiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 2 */
/* no static exports found */
/* all exports used */
/*!********************************!*\
  !*** ./src/Constants/index.ts ***!
  \********************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** Hovered state when navigation through upArrow/downArrow while options is open */\nexports.HOVERED = \"hovered\";\n/**\n * Key down states (keyCodes)\n */\nexports.KEY_PRESS_STATES = {\n    UP: 38,\n    DOWN: 40,\n    ENTER: 13,\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Db25zdGFudHMvaW5kZXgudHM/NGQ1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbi8qKiBIb3ZlcmVkIHN0YXRlIHdoZW4gbmF2aWdhdGlvbiB0aHJvdWdoIHVwQXJyb3cvZG93bkFycm93IHdoaWxlIG9wdGlvbnMgaXMgb3BlbiAqL1xuZXhwb3J0IGNvbnN0IEhPVkVSRUQgPSBcImhvdmVyZWRcIjtcblxuLyoqXG4gKiBLZXkgZG93biBzdGF0ZXMgKGtleUNvZGVzKVxuICovXG5leHBvcnQgY29uc3QgS0VZX1BSRVNTX1NUQVRFUyA9IHtcbiAgICBVUDogMzgsXG4gICAgRE9XTjogNDAsXG4gICAgRU5URVI6IDEzLFxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3NyYy9Db25zdGFudHMvaW5kZXgudHMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/* no static exports found */
/* all exports used */
/*!****************************!*\
  !*** ./src/Utils/index.ts ***!
  \****************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Utils Class\n * @author Islam Attrash\n */\nvar Utils = /** @class */ (function () {\n    function Utils() {\n    }\n    /**\n     * Throw error message\n     * @param error - Error message\n     */\n    Utils.throwErrorInConsole = function (error) {\n        console.error(error);\n    };\n    return Utils;\n}());\nexports.Utils = Utils;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9VdGlscy9pbmRleC50cz8yZGJjIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBVdGlscyBDbGFzc1xuICogQGF1dGhvciBJc2xhbSBBdHRyYXNoXG4gKi9cbmV4cG9ydCBjbGFzcyBVdGlscyB7XG4gIC8qKlxuICAgKiBUaHJvdyBlcnJvciBtZXNzYWdlXG4gICAqIEBwYXJhbSBlcnJvciAtIEVycm9yIG1lc3NhZ2VcbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgdGhyb3dFcnJvckluQ29uc29sZShlcnJvcjogRXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvVXRpbHMvaW5kZXgudHMiXSwibWFwcGluZ3MiOiI7O0FBQ0E7OztBQUdBO0FBQ0E7QUFBQTtBQVFBO0FBUEE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQVJBOyIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/* no static exports found */
/* all exports used */
/*!************************************************!*\
  !*** ./src/Components/InfiniteAutocomplete.ts ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [0, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar InputComponent_1 = __webpack_require__(/*! ./InputComponent */ 0);\nvar OptionsComponent_1 = __webpack_require__(/*! ./OptionsComponent */ 1);\nvar index_1 = __webpack_require__(/*! ../Constants/index */ 2);\nvar index_2 = __webpack_require__(/*! ../Utils/index */ 3);\n/**\n * Default Input in infinite-autocomplete component\n */\nexports.InputComponent = InputComponent_1.InputComponent;\n/**\n * Default Input in infinite-autocomplete component\n */\nexports.OptionsComponent = OptionsComponent_1.OptionsComponent;\n/**\n * infinite-autocomplete component implementation\n * @author Islam Attrash\n */\nvar InfiniteAutocomplete = /** @class */ (function () {\n    /**\n     * constructor for InfiniteAutocomplete class\n     * Enabling pluggable system linked with Interfaces only\n     * @param element - HTMLElement to append the infinite-autocomplete in it\n     * @param config - InfiniteAutocomplete config options\n     * @param optionComponent - Option component implementation to be injected (or default)\n     * @param inputComponent - Input component implementation to be injected (or default)\n     * @param optionsComponent - Options component implementation to be injected (or default)\n     */\n    function InfiniteAutocomplete(element, config) {\n        var _this = this;\n        this.page = 1;\n        this.searchedText = \"\";\n        this.isDestroyed = false;\n        this.preventMoreRequests = false;\n        this.fetchingData = false;\n        /**\n         * Default configuration object\n         */\n        this.defaultConfig = {\n            fetchSize: 10,\n            maxHeight: \"160px\",\n            customizedInput: InputComponent_1.InputComponent,\n            customizedOptions: OptionsComponent_1.OptionsComponent,\n        };\n        /**\n         * Set the config object with extending\n         * @param config - infinite-autocomplete configuration object\n         */\n        this.setConfig = function (config) {\n            _this.destroy();\n            _this.config = __assign({}, _this.config, config);\n            _this.inputComponent = new _this.config.customizedInput();\n            _this.optionsComponent = new _this.config.customizedOptions();\n            _this.init();\n        };\n        /**\n         * Destroy the infinite-autocomplete and unbind all events\n         */\n        this.destroy = function () {\n            if (_this.isDestroyed) {\n                return;\n            }\n            if (!_this.isOptionsHidden()) {\n                _this.clearOptions();\n            }\n            var optionsList = _this.getOptionsBaseElement();\n            optionsList.removeEventListener(\"scroll\", _this.scrollReachedBottomHandler);\n            var inputEle = _this.getInputElement();\n            inputEle.removeEventListener(\"input\", _this.onInputChange);\n            inputEle.removeEventListener(\"click\", _this.onInputChange);\n            inputEle.removeEventListener(\"keydown\", _this.onKeyPressed);\n            document.removeEventListener(\"click\", _this.onDocumentClickHandler);\n            document.removeEventListener(\"keydown\", _this.onEscapeEventHandler);\n            _this.element.innerHTML = \"\";\n            _this.isDestroyed = true;\n        };\n        /**\n         * Initialize hook that get executed immediatly after using the infinite-autocomplete component\n         */\n        this.init = function () {\n            _this.applyStylesRules();\n            _this.appendInfiniteAutocompleteWrapperClass();\n            _this.linkInputComponent();\n            _this.linkOptionsComponent();\n            _this.bindScrollReachBottomEvent();\n            _this.bindEscapeEvent();\n            _this.bindOutSideClickEvent();\n            _this.isDestroyed = false;\n        };\n        /**\n         * (#1) Binds a click handler to detect where the user clicked\n         * If click is out side the main wrapper area then close options\n         */\n        this.bindOutSideClickEvent = function () {\n            document.addEventListener(\"click\", _this.onDocumentClickHandler);\n        };\n        /**\n         * on document click handler\n         * @param event - Event\n         */\n        this.onDocumentClickHandler = function (event) {\n            if (!_this.isOptionsHidden()) {\n                var clickedOutSide = _this.checkIfClickedOutSideTheAutocompleteComponents(event.target);\n                if (clickedOutSide) {\n                    _this.clearOptions();\n                }\n            }\n        };\n        /**\n         * Check if click is outside the plugin\n         * @param element - HTMLElement\n         */\n        this.checkIfClickedOutSideTheAutocompleteComponents = function (element) {\n            if (element === null) {\n                return true;\n            }\n            else if (element === _this.element) {\n                return false;\n            }\n            else {\n                return _this.checkIfClickedOutSideTheAutocompleteComponents(element.parentElement);\n            }\n        };\n        /**\n         * (#11) Binds escape event handler to clear the options when clicking Esc\n         */\n        this.bindEscapeEvent = function () {\n            document.addEventListener(\"keydown\", _this.onEscapeEventHandler);\n        };\n        /**\n         * Escape event handler\n         * @param e - KeyboardEvent\n         */\n        this.onEscapeEventHandler = function (e) {\n            if (e.keyCode === 27 && !_this.isOptionsHidden()) {\n                _this.clearOptions();\n            }\n        };\n        /**\n         * Append infinite autocomplete main wrapper className\n         */\n        this.appendInfiniteAutocompleteWrapperClass = function () {\n            if (!_this.element.className || _this.element.className.indexOf(\"infinite-autocomplete-wrapper\") === -1) {\n                _this.element.className = _this.element\n                    .className\n                    .split(\" \")\n                    .concat([\"infinite-autocomplete-wrapper\"])\n                    .filter(function (c) { return c; })\n                    .join(\" \");\n            }\n        };\n        /**\n         * Reset current page\n         */\n        this.resetCurrentPage = function () {\n            _this.page = 1;\n        };\n        /**\n         * Link input component into the input wrapper\n         */\n        this.linkInputComponent = function () {\n            var MissingInputElementInInputComponentExceptionMsg = new Error(\"Customized input should contain input element <input />\");\n            var inputWrapperEle = document.createElement(\"div\");\n            inputWrapperEle.className = \"infinite-autocomplete-input-wrapper\";\n            inputWrapperEle.innerHTML = _this.inputComponent.render();\n            var inputEle = inputWrapperEle.querySelector(\"input\");\n            if (!inputEle) {\n                index_2.Utils.throwErrorInConsole(MissingInputElementInInputComponentExceptionMsg);\n                throw MissingInputElementInInputComponentExceptionMsg;\n            }\n            inputEle\n                .addEventListener(\"input\", _this.onInputChange);\n            // (#2) Start to show options when focus on the input\n            inputEle\n                .addEventListener(\"click\", _this.onInputChange);\n            inputEle\n                .addEventListener(\"keydown\", _this.onKeyPressed);\n            _this.element.appendChild(inputWrapperEle);\n        };\n        /**\n         * On keydown pressing in input element\n         * @param keydownEvent - pressing key event\n         */\n        this.onKeyPressed = function (keydownEvent) {\n            if (!_this.isOptionsHidden()) {\n                var currentHovered = _this.getNavigationIndex();\n                if (currentHovered === -1) {\n                    if (keydownEvent.keyCode === index_1.KEY_PRESS_STATES.DOWN) {\n                        _this.toggleHoveredState(0, keydownEvent);\n                    }\n                }\n                else {\n                    switch (keydownEvent.keyCode) {\n                        case index_1.KEY_PRESS_STATES.DOWN:\n                            _this.toggleHoveredState(currentHovered + 1, keydownEvent);\n                            break;\n                        case index_1.KEY_PRESS_STATES.UP:\n                            _this.toggleHoveredState(currentHovered - 1, keydownEvent);\n                            break;\n                        case index_1.KEY_PRESS_STATES.ENTER:\n                            _this.clickOnHovered();\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        };\n        /**\n         * Click on hovered element\n         */\n        this.clickOnHovered = function () {\n            var optionsList = _this.getOptionsBaseElement();\n            var hoveredElement = optionsList.querySelector(\".\" + index_1.HOVERED);\n            if (hoveredElement) {\n                hoveredElement.click();\n            }\n        };\n        /**\n         * Simulate Scrolled to bottom\n         */\n        this.simulateScrollToBottom = function () {\n            var optionsList = _this.getOptionsBaseElement();\n            var scrollEvent = new Event(\"scroll\", { bubbles: true });\n            optionsList.scrollTop = 10000; // Simulate reached bottom\n            optionsList.dispatchEvent(scrollEvent);\n        };\n        /**\n         * Toggle hovered state on specific index in options list\n         * @param index - The index to be applied as hovered\n         */\n        this.toggleHoveredState = function (index, keydownEvent) {\n            var optionsList = _this.getOptionsBaseElement();\n            if (index === optionsList.children.length) {\n                _this.simulateScrollToBottom();\n            }\n            if (index >= 0 && index < optionsList.children.length) {\n                var hoveredElement = optionsList.querySelector(\".\" + index_1.HOVERED);\n                if (hoveredElement) {\n                    hoveredElement.className = hoveredElement\n                        .className\n                        .split(\" \")\n                        .filter(function (e) { return e !== index_1.HOVERED; })\n                        .join(\" \")\n                        .trim();\n                }\n                var targetElement = optionsList.children[index];\n                targetElement.className += \" \" + index_1.HOVERED;\n                // If hovered is not in the scrollable view\n                if (targetElement.offsetTop < optionsList.scrollTop || (targetElement.offsetTop - optionsList.scrollTop > optionsList.clientHeight)) {\n                    switch (keydownEvent.keyCode) {\n                        case index_1.KEY_PRESS_STATES.UP:\n                            targetElement.scrollIntoView(true);\n                            break;\n                        case index_1.KEY_PRESS_STATES.DOWN:\n                            targetElement.scrollIntoView(false);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n        };\n        /**\n         * Get navigation index if options is open\n         * @returns Options current index\n         */\n        this.getNavigationIndex = function () {\n            var optionsList = _this.getOptionsBaseElement();\n            for (var i = 0; i < optionsList.children.length; i++) {\n                var option = optionsList.children[i];\n                if (option.className.indexOf(index_1.HOVERED) !== -1) {\n                    return i;\n                }\n            }\n            return -1;\n        };\n        /**\n         * Input component `change` event handler\n         * @param inputChangeEvent - Input change event handler\n         */\n        this.onInputChange = function (inputChangeEvent) {\n            var target = inputChangeEvent.currentTarget;\n            // If user pass special behavior for typing via configuration\n            if (_this.inputComponent.onInputChange) {\n                _this.inputComponent.onInputChange(target, target.value);\n            }\n            // If we type always fetch data and build options\n            // If we click on input and the options is hidden build the options\n            // If we click on input and the options is already opened don't do anything\n            if (inputChangeEvent.type === \"input\" ||\n                (inputChangeEvent.type === \"click\" && _this.isOptionsHidden())) {\n                _this.buildOptions(target.value, true);\n            }\n        };\n        /**\n         * Link options component into the infinite autocomplete component\n         */\n        this.linkOptionsComponent = function () {\n            var optionsWrapperEle = document.createElement(\"div\");\n            optionsWrapperEle.className = \"infinite-autocomplete-options-wrapper\";\n            optionsWrapperEle.innerHTML = _this.optionsComponent.render();\n            var optionsEle = optionsWrapperEle.querySelector(_this.optionsComponent.listElementSelector);\n            _this.setElementVisiblity(optionsWrapperEle, false);\n            optionsEle.style.overflow = \"scroll\";\n            optionsEle.style.overflowX = \"hidden\";\n            optionsEle.style.border = \"1px solid #bcbcbc\";\n            optionsEle.style.paddingBottom = \"5px\";\n            optionsEle.style.maxHeight = _this.config.maxHeight || null;\n            _this.element.appendChild(optionsWrapperEle);\n        };\n        /**\n         * Check if options wrapper hidden or not\n         * @returns true if hidden, or else false\n         */\n        this.isOptionsHidden = function () {\n            var optionsWrapper = _this.element.querySelector(\".infinite-autocomplete-options-wrapper\");\n            return optionsWrapper.className\n                .indexOf(\"infinite-autocomplete-hidden-element\") > -1;\n        };\n        /**\n         * Apply the style rules for the infinite autocomplete plugin and it's components\n         */\n        this.applyStylesRules = function () {\n            // Main wrapper style rules\n            var isMainWrapperStyleApplied = document.head.querySelector(\"#infinite-autocomplete-wrapper-style\");\n            if (!isMainWrapperStyleApplied) {\n                var mainWrapperStyle = document.createElement(\"style\");\n                mainWrapperStyle.id = \"infinite-autocomplete-wrapper-style\";\n                mainWrapperStyle.innerHTML = \"\\n          .infinite-autocomplete-wrapper {\\n              position: relative;\\n          }\\n      \";\n                document.head.appendChild(mainWrapperStyle);\n            }\n            // Hidden element style rules\n            var isHiddenStyleApplied = document.head.querySelector(\"#infinite-autocomplete-hidden-style\");\n            if (!isHiddenStyleApplied) {\n                var hiddenStyle = document.createElement(\"style\");\n                hiddenStyle.id = \"infinite-autocomplete-hidden-style\";\n                hiddenStyle.innerHTML = \"\\n          .infinite-autocomplete-hidden-element {\\n              visibility: hidden;\\n              z-index: -1;\\n          }\\n      \";\n                document.head.appendChild(hiddenStyle);\n            }\n            // Defaults style rules\n            var isDefaultsStyleApplied = document.head.querySelector(\"#infinite-autocomplete-defaults-style\");\n            if (!isDefaultsStyleApplied) {\n                var defaultsStyle = document.createElement(\"style\");\n                defaultsStyle.id = \"infinite-autocomplete-defaults-style\";\n                defaultsStyle.innerHTML = \"\\n          .infinite-autocomplete-input-wrapper .infinite-autocomplete-default-input {\\n              height: 28px;\\n              border-radius: 8px;\\n              box-shadow: inset 0px 0px 15px -4px transparent;\\n          }\\n          .infinite-autocomplete-options-wrapper .infinite-autocomplete-default-options {\\n              list-style-type: none;\\n              margin-top: 0;\\n              padding-left: 0;\\n              margin-bottom: 0;\\n          }\\n          .infinite-autocomplete-options-wrapper .infinite-autocomplete-default-options li {\\n              padding: 5px 10px 10px 10px;\\n          }\\n          .infinite-autocomplete-options-wrapper .infinite-autocomplete-default-options li.hovered {\\n              background: #d5ebff;\\n              color: black;\\n              cursor: pointer;\\n          }\\n      \";\n                document.head.appendChild(defaultsStyle);\n            }\n            // Input style rules\n            var isInputStyleApplied = document.head.querySelector(\"#infinite-autocomplete-input-style\");\n            if (!isInputStyleApplied) {\n                var inputStyle = document.createElement(\"style\");\n                inputStyle.id = \"infinite-autocomplete-input-style\";\n                inputStyle.innerHTML = \"\\n          .infinite-autocomplete-input-wrapper input {\\n              width: 100%;\\n          }\\n      \";\n                document.head.appendChild(inputStyle);\n            }\n            // Options style rules\n            var isOptionsStyleApplied = document.head.querySelector(\"#infinite-autocomplete-options-style\");\n            if (!isOptionsStyleApplied) {\n                var optionsStyle = document.createElement(\"style\");\n                optionsStyle.id = \"infinite-autocomplete-options-style\";\n                optionsStyle.innerHTML = \"\\n          .infinite-autocomplete-options-wrapper {\\n              position: absolute;\\n              z-index: 10;\\n              background: white;\\n          }\\n      \";\n                document.head.appendChild(optionsStyle);\n            }\n            // Scrollbar style rules\n            var isScrollbarStyleApplied = document.head.querySelector(\"#infinite-autocomplete-scrollbar-style\");\n            if (!isScrollbarStyleApplied) {\n                var specialScroll = document.createElement(\"style\");\n                specialScroll.id = \"infinite-autocomplete-scrollbar-style\";\n                specialScroll.innerHTML = \"\\n          .infinite-autocomplete-wrapper ::-webkit-scrollbar {\\n                  width: 4px;\\n              }\\n\\n              .infinite-autocomplete-wrapper ::-webkit-scrollbar-track {\\n                  -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.3);\\n                  -webkit-border-radius: 10px;\\n                  border-radius: 10px;\\n              }\\n\\n              .infinite-autocomplete-wrapper ::-webkit-scrollbar-thumb {\\n                  -webkit-border-radius: 10px;\\n                  border-radius: 10px;\\n                  background: rgba(128, 128, 128, 0.8);\\n                  -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);\\n              }\\n              .infinite-autocomplete-wrapper ::-webkit-scrollbar-thumb:window-inactive {\\n                  background: rgba(255,0,0,0.4);\\n              }\\n      \";\n                document.head.appendChild(specialScroll);\n            }\n        };\n        /**\n         * Binds a scroll event handler on the options\n         */\n        this.bindScrollReachBottomEvent = function () {\n            var optionsEle = _this.getOptionsBaseElement();\n            optionsEle.addEventListener(\"scroll\", _this.scrollReachedBottomHandler);\n        };\n        /**\n         * Scroll reached bottom handler\n         * @param e - Scroll event object\n         */\n        this.scrollReachedBottomHandler = function (e) {\n            var optionsEle = e.currentTarget;\n            if (!_this.fetchingData && !_this.preventMoreRequests && !_this.isOptionsHidden()) {\n                if (optionsEle.scrollTop + optionsEle.clientHeight >= optionsEle.scrollHeight) {\n                    _this.page++;\n                    _this.buildOptions(_this.getInputElement().value, false);\n                }\n            }\n        };\n        /**\n         * Clears the options list tag with removing the click event handlers\n         * unbind the `scroll` event from the options\n         * (Garbage collecting)\n         */\n        this.clearOptions = function () {\n            _this.detachOptionEventHandlers(_this.getOptionsBaseElement()\n                .querySelectorAll(\"[infinite-clickable]\"));\n            _this.resetCurrentPage();\n            _this.preventMoreRequests = false;\n            var optionListElement = _this.getOptionsBaseElement();\n            _this.setElementVisiblity(_this.element.querySelector(\".infinite-autocomplete-options-wrapper\"), false);\n            optionListElement.innerHTML = \"\";\n        };\n        /**\n         * Option click event handler\n         * @param clickEvent\n         */\n        this.onOptionClickEvent = function (clickEvent) {\n            if (_this.config.onSelect) {\n                _this.config.onSelect(clickEvent.currentTarget, clickEvent.currentTarget.data);\n            }\n            _this.clearOptions();\n            _this.setInput(clickEvent.currentTarget.data.text);\n        };\n        /**\n         * On hovering on option row\n         * @param event - Hover Mouse Event\n         */\n        this.onOptionHoverEvent = function (event) {\n            var optionsList = _this.getOptionsBaseElement();\n            var hoveredElement = optionsList.querySelector(\".\" + index_1.HOVERED);\n            if (hoveredElement) {\n                hoveredElement.className = hoveredElement\n                    .className\n                    .split(\" \")\n                    .filter(function (e) { return e !== index_1.HOVERED; })\n                    .join(\" \")\n                    .trim();\n            }\n            var target = event.currentTarget;\n            target.className += \" \" + index_1.HOVERED;\n        };\n        this.element = element;\n        this.config = __assign({}, this.defaultConfig, config);\n        this.inputComponent = new this.config.customizedInput();\n        this.optionsComponent = new this.config.customizedOptions();\n        this.init();\n    }\n    /**\n     * Sets the element visiblity\n     * @param element - HTMLElement\n     * @param visible - visibility status\n     */\n    InfiniteAutocomplete.prototype.setElementVisiblity = function (element, visible) {\n        if (visible) {\n            element.className = element.className\n                .split(\" \")\n                .filter(function (e) { return e !== \"infinite-autocomplete-hidden-element\"; })\n                .join(\" \");\n        }\n        else {\n            if (element.className.indexOf(\"infinite-autocomplete-hidden-element\") === -1) {\n                element.className += \" infinite-autocomplete-hidden-element\";\n            }\n        }\n    };\n    /**\n     * Get options base HTMLElement\n     * @returns HTMLElement\n     */\n    InfiniteAutocomplete.prototype.getOptionsBaseElement = function () {\n        var optionsWrapperExceptionMsg = new Error(\"Couldn't get the options base element.\");\n        if (this.element) {\n            var optionsWrapper = this.element\n                .querySelector(\".infinite-autocomplete-options-wrapper\");\n            if (optionsWrapper) {\n                return optionsWrapper\n                    .querySelector(this.optionsComponent.listElementSelector);\n            }\n            else {\n                index_2.Utils.throwErrorInConsole(optionsWrapperExceptionMsg);\n                throw optionsWrapperExceptionMsg;\n            }\n        }\n        else {\n            index_2.Utils.throwErrorInConsole(optionsWrapperExceptionMsg);\n            throw optionsWrapperExceptionMsg;\n        }\n    };\n    /**\n     * Detaching the event handlers over the option elements\n     */\n    InfiniteAutocomplete.prototype.detachOptionEventHandlers = function (elements) {\n        for (var i = 0; i < elements.length; i++) {\n            elements[i].removeEventListener(\"click\", this.onOptionClickEvent);\n            elements[i].removeEventListener(\"mouseover\", this.onOptionHoverEvent);\n        }\n    };\n    /**\n     * Get input HTML element below infinite-autocomplete-input-wrapper\n     * @returns HTMLInputElement\n     */\n    InfiniteAutocomplete.prototype.getInputElement = function () {\n        var inputElementExceptionMsg = new Error(\"Couldn't get the input element.\");\n        if (this.element) {\n            var inputWrapper = this.element\n                .querySelector(\".infinite-autocomplete-input-wrapper\");\n            if (inputWrapper) {\n                return inputWrapper\n                    .querySelector(\"input\");\n            }\n            else {\n                index_2.Utils.throwErrorInConsole(inputElementExceptionMsg);\n                throw inputElementExceptionMsg;\n            }\n        }\n        else {\n            index_2.Utils.throwErrorInConsole(inputElementExceptionMsg);\n            throw inputElementExceptionMsg;\n        }\n    };\n    /**\n     * Set input shown text\n     * @param text\n     */\n    InfiniteAutocomplete.prototype.setInput = function (text) {\n        this.getInputElement()\n            .value = text;\n    };\n    /**\n     * Get data based on text, page and fetchSize\n     * @param text\n     * @param page\n     * @param fetchSize\n     */\n    InfiniteAutocomplete.prototype.getData = function (text, page, fetchSize) {\n        return __awaiter(this, void 0, void 0, function () {\n            var dataSourceMissingExceptionMsg, from, to, staticData, apiData;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        this.searchedText = text;\n                        dataSourceMissingExceptionMsg = new Error(\"You must pass data or getDataFromApi function via config\");\n                        if (!this.config.data) return [3 /*break*/, 1];\n                        this.fetchingData = true;\n                        from = (page - 1) * fetchSize;\n                        to = (fetchSize * (page - 1)) + fetchSize;\n                        staticData = this.config.data\n                            .filter(function (option) { return option.text.toLowerCase().indexOf(text.toLowerCase()) !== -1; })\n                            .slice(from, to);\n                        this.fetchingData = false;\n                        return [2 /*return*/, staticData];\n                    case 1:\n                        if (!this.config.getDataFromApi) return [3 /*break*/, 3];\n                        this.fetchingData = true;\n                        return [4 /*yield*/, this.config.getDataFromApi(text, page, fetchSize)];\n                    case 2:\n                        apiData = _a.sent();\n                        this.fetchingData = false;\n                        if (this.searchedText === text &&\n                            this.page === page &&\n                            this.config.fetchSize === fetchSize) {\n                            return [2 /*return*/, apiData];\n                        }\n                        else {\n                            return [2 /*return*/, null];\n                        }\n                        return [3 /*break*/, 4];\n                    case 3:\n                        index_2.Utils.throwErrorInConsole(dataSourceMissingExceptionMsg);\n                        throw dataSourceMissingExceptionMsg;\n                    case 4: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Build the options inner tags in options list tag based on the text passed and the data in config\n     * @param text - Text to search on in the autocomplete\n     * @param clearPreviousData - Flag to clear previous options and override with the new one\n     */\n    InfiniteAutocomplete.prototype.buildOptions = function (text, clearPreviousData) {\n        if (clearPreviousData === void 0) { clearPreviousData = true; }\n        return __awaiter(this, void 0, void 0, function () {\n            var _this = this;\n            var fetchSizeExceptionMsg, optionListElement, filteredOptions, chunkClientHeight, maxHeightNumber, optionsWrapperEle, optionsEle;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fetchSizeExceptionMsg = new Error(\"fetchSize must be overriden with correct numeric value\");\n                        optionListElement = this.getOptionsBaseElement();\n                        if (clearPreviousData) {\n                            this.clearOptions();\n                        }\n                        if (!this.config.fetchSize) return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.getData(text, this.page, this.config.fetchSize)];\n                    case 1:\n                        filteredOptions = _a.sent();\n                        if (filteredOptions !== null) {\n                            if (filteredOptions.length < this.config.fetchSize) {\n                                // Stop fetching more chunks whenever you get less than the chunk fetch size\n                                this.preventMoreRequests = true;\n                            }\n                            filteredOptions\n                                .forEach(function (option) {\n                                var optionElementTemplate = _this.optionsComponent.renderOption(option);\n                                var tempElement = document.createElement(\"div\");\n                                tempElement.innerHTML = optionElementTemplate;\n                                var optionElement = tempElement.childNodes[0];\n                                optionElement.data = { text: option.text, value: option.value };\n                                optionElement.setAttribute(\"infinite-clickable\", \"\");\n                                optionElement.addEventListener(\"click\", _this.onOptionClickEvent);\n                                optionElement.addEventListener(\"mouseover\", _this.onOptionHoverEvent);\n                                optionListElement.appendChild(optionElement);\n                            });\n                            if (filteredOptions.length > 0) {\n                                chunkClientHeight = optionListElement.children[0].clientHeight;\n                                // Check if maxHeight is fits the chunk size list\n                                if (this.config.maxHeight) {\n                                    maxHeightNumber = parseInt(this.config.maxHeight, 10);\n                                    if (maxHeightNumber >= chunkClientHeight * this.config.fetchSize) {\n                                        this.config.maxHeight = (chunkClientHeight * this.config.fetchSize - 5) + \"px\";\n                                        optionsWrapperEle = this.element.querySelector(\".infinite-autocomplete-options-wrapper\");\n                                        optionsEle = optionsWrapperEle.querySelector(this.optionsComponent.listElementSelector);\n                                        optionsEle.style.maxHeight = this.config.maxHeight;\n                                    }\n                                }\n                            }\n                        }\n                        if (optionListElement.innerHTML !== \"\") {\n                            this.setElementVisiblity(this.element.querySelector(\".infinite-autocomplete-options-wrapper\"), true);\n                        }\n                        else {\n                            this.setElementVisiblity(this.element.querySelector(\".infinite-autocomplete-options-wrapper\"), false);\n                        }\n                        return [3 /*break*/, 3];\n                    case 2:\n                        index_2.Utils.throwErrorInConsole(fetchSizeExceptionMsg);\n                        _a.label = 3;\n                    case 3: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return InfiniteAutocomplete;\n}());\nexports.InfiniteAutocomplete = InfiniteAutocomplete;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9Db21wb25lbnRzL0luZmluaXRlQXV0b2NvbXBsZXRlLnRzPzA1ODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5wdXRDb21wb25lbnQgYXMgZGVmYXVsdElucHV0SW1wbCB9IGZyb20gXCIuL0lucHV0Q29tcG9uZW50XCI7XG5pbXBvcnQgeyBPcHRpb25zQ29tcG9uZW50IGFzIGRlZmF1bHRPcHRpb25zSW1wbCB9IGZyb20gXCIuL09wdGlvbnNDb21wb25lbnRcIjtcbmltcG9ydCB7IEluZmluaXRlQXV0b2NvbXBsZXRlQ29uZmlnIH0gZnJvbSBcIi4uL0ludGVyZmFjZXMvSW5maW5pdGVBdXRvY29tcGxldGVDb25maWdcIjtcbmltcG9ydCB7IElJbnB1dENvbXBvbmVudCwgSUlucHV0Q29tcG9lbmVudENvbnN0cnVjdG9yIH0gZnJvbSBcIi4uL0ludGVyZmFjZXMvSUlucHV0Q29tcG9uZW50XCI7XG5pbXBvcnQgeyBJT3B0aW9uc0NvbXBvbmVudCwgSU9wdGlvbnNDb21wb25lbnRDb25zdHJ1Y3RvciB9IGZyb20gXCIuLi9JbnRlcmZhY2VzL0lPcHRpb25zQ29tcG9uZW50XCI7XG5pbXBvcnQgeyBJSW5maW5pdGVBdXRvY29tcGxldGUgfSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9JSW5maW5pdGVBdXRvY29tcGxldGVcIjtcbmltcG9ydCB7IEluZmluaXRlQXV0b2NvbXBsZXRlQ29uZmlnUGFyYW1zIH0gZnJvbSBcIi4uL0ludGVyZmFjZXMvSW5maW5pdGVBdXRvY29tcGxldGVDb25maWdQYXJhbXNcIjtcbmltcG9ydCB7IElPcHRpb24gfSBmcm9tIFwiLi4vSW50ZXJmYWNlcy9JT3B0aW9uXCI7XG5pbXBvcnQgeyBIT1ZFUkVELCBLRVlfUFJFU1NfU1RBVEVTIH0gZnJvbSBcIi4uL0NvbnN0YW50cy9pbmRleFwiO1xuaW1wb3J0IHsgVXRpbHMgfSBmcm9tIFwiLi4vVXRpbHMvaW5kZXhcIjtcblxuLyoqXG4gKiBEZWZhdWx0IElucHV0IGluIGluZmluaXRlLWF1dG9jb21wbGV0ZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IElucHV0Q29tcG9uZW50ID0gZGVmYXVsdElucHV0SW1wbDtcblxuLyoqXG4gKiBEZWZhdWx0IElucHV0IGluIGluZmluaXRlLWF1dG9jb21wbGV0ZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGNvbnN0IE9wdGlvbnNDb21wb25lbnQgPSBkZWZhdWx0T3B0aW9uc0ltcGw7XG5cbi8qKlxuICogaW5maW5pdGUtYXV0b2NvbXBsZXRlIGNvbXBvbmVudCBpbXBsZW1lbnRhdGlvblxuICogQGF1dGhvciBJc2xhbSBBdHRyYXNoXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmZpbml0ZUF1dG9jb21wbGV0ZSBpbXBsZW1lbnRzIElJbmZpbml0ZUF1dG9jb21wbGV0ZSB7XG5cbiAgcHJpdmF0ZSBlbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBpbnB1dENvbXBvbmVudDogSUlucHV0Q29tcG9uZW50O1xuICBwcml2YXRlIG9wdGlvbnNDb21wb25lbnQ6IElPcHRpb25zQ29tcG9uZW50O1xuICBwcml2YXRlIHBhZ2U6IG51bWJlciA9IDE7XG4gIHByaXZhdGUgc2VhcmNoZWRUZXh0OiBzdHJpbmcgPSBcIlwiO1xuICBwcml2YXRlIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gIHByaXZhdGUgY29uZmlnOiBJbmZpbml0ZUF1dG9jb21wbGV0ZUNvbmZpZztcbiAgcHJpdmF0ZSBwcmV2ZW50TW9yZVJlcXVlc3RzOiBib29sZWFuID0gZmFsc2U7XG4gIHByaXZhdGUgZmV0Y2hpbmdEYXRhOiBib29sZWFuID0gZmFsc2U7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHByaXZhdGUgZGVmYXVsdENvbmZpZzogSW5maW5pdGVBdXRvY29tcGxldGVDb25maWcgPSB7XG4gICAgZmV0Y2hTaXplOiAxMCxcbiAgICBtYXhIZWlnaHQ6IFwiMTYwcHhcIixcbiAgICBjdXN0b21pemVkSW5wdXQ6IGRlZmF1bHRJbnB1dEltcGwsXG4gICAgY3VzdG9taXplZE9wdGlvbnM6IGRlZmF1bHRPcHRpb25zSW1wbCxcbiAgfTtcblxuICAvKipcbiAgICogY29uc3RydWN0b3IgZm9yIEluZmluaXRlQXV0b2NvbXBsZXRlIGNsYXNzXG4gICAqIEVuYWJsaW5nIHBsdWdnYWJsZSBzeXN0ZW0gbGlua2VkIHdpdGggSW50ZXJmYWNlcyBvbmx5XG4gICAqIEBwYXJhbSBlbGVtZW50IC0gSFRNTEVsZW1lbnQgdG8gYXBwZW5kIHRoZSBpbmZpbml0ZS1hdXRvY29tcGxldGUgaW4gaXRcbiAgICogQHBhcmFtIGNvbmZpZyAtIEluZmluaXRlQXV0b2NvbXBsZXRlIGNvbmZpZyBvcHRpb25zXG4gICAqIEBwYXJhbSBvcHRpb25Db21wb25lbnQgLSBPcHRpb24gY29tcG9uZW50IGltcGxlbWVudGF0aW9uIHRvIGJlIGluamVjdGVkIChvciBkZWZhdWx0KVxuICAgKiBAcGFyYW0gaW5wdXRDb21wb25lbnQgLSBJbnB1dCBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gYmUgaW5qZWN0ZWQgKG9yIGRlZmF1bHQpXG4gICAqIEBwYXJhbSBvcHRpb25zQ29tcG9uZW50IC0gT3B0aW9ucyBjb21wb25lbnQgaW1wbGVtZW50YXRpb24gdG8gYmUgaW5qZWN0ZWQgKG9yIGRlZmF1bHQpXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBIVE1MRWxlbWVudCwgY29uZmlnPzogSW5maW5pdGVBdXRvY29tcGxldGVDb25maWdQYXJhbXMpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmRlZmF1bHRDb25maWcsIC4uLmNvbmZpZyB9O1xuICAgIHRoaXMuaW5wdXRDb21wb25lbnQgPSBuZXcgdGhpcy5jb25maWcuY3VzdG9taXplZElucHV0KCk7XG4gICAgdGhpcy5vcHRpb25zQ29tcG9uZW50ID0gbmV3IHRoaXMuY29uZmlnLmN1c3RvbWl6ZWRPcHRpb25zKCk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBjb25maWcgb2JqZWN0IHdpdGggZXh0ZW5kaW5nXG4gICAqIEBwYXJhbSBjb25maWcgLSBpbmZpbml0ZS1hdXRvY29tcGxldGUgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICovXG4gIHB1YmxpYyBzZXRDb25maWcgPSAoY29uZmlnOiBJbmZpbml0ZUF1dG9jb21wbGV0ZUNvbmZpZ1BhcmFtcykgPT4ge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICAgIHRoaXMuY29uZmlnID0geyAuLi50aGlzLmNvbmZpZywgLi4uY29uZmlnIH07XG4gICAgdGhpcy5pbnB1dENvbXBvbmVudCA9IG5ldyB0aGlzLmNvbmZpZy5jdXN0b21pemVkSW5wdXQoKTtcbiAgICB0aGlzLm9wdGlvbnNDb21wb25lbnQgPSBuZXcgdGhpcy5jb25maWcuY3VzdG9taXplZE9wdGlvbnMoKTtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95IHRoZSBpbmZpbml0ZS1hdXRvY29tcGxldGUgYW5kIHVuYmluZCBhbGwgZXZlbnRzXG4gICAqL1xuICBwdWJsaWMgZGVzdHJveSA9ICgpID0+IHtcbiAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5pc09wdGlvbnNIaWRkZW4oKSkge1xuICAgICAgdGhpcy5jbGVhck9wdGlvbnMoKTtcbiAgICB9XG5cbiAgICBsZXQgb3B0aW9uc0xpc3QgPSB0aGlzLmdldE9wdGlvbnNCYXNlRWxlbWVudCgpO1xuICAgIG9wdGlvbnNMaXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYHNjcm9sbGAsIHRoaXMuc2Nyb2xsUmVhY2hlZEJvdHRvbUhhbmRsZXIpO1xuICAgIGxldCBpbnB1dEVsZSA9IHRoaXMuZ2V0SW5wdXRFbGVtZW50KCk7XG4gICAgaW5wdXRFbGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihgaW5wdXRgLCB0aGlzLm9uSW5wdXRDaGFuZ2UpO1xuICAgIGlucHV0RWxlLnJlbW92ZUV2ZW50TGlzdGVuZXIoYGNsaWNrYCwgdGhpcy5vbklucHV0Q2hhbmdlKTtcbiAgICBpbnB1dEVsZS5yZW1vdmVFdmVudExpc3RlbmVyKGBrZXlkb3duYCwgdGhpcy5vbktleVByZXNzZWQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoYGNsaWNrYCwgdGhpcy5vbkRvY3VtZW50Q2xpY2tIYW5kbGVyKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCB0aGlzLm9uRXNjYXBlRXZlbnRIYW5kbGVyKTtcbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gYGA7XG4gICAgdGhpcy5pc0Rlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBob29rIHRoYXQgZ2V0IGV4ZWN1dGVkIGltbWVkaWF0bHkgYWZ0ZXIgdXNpbmcgdGhlIGluZmluaXRlLWF1dG9jb21wbGV0ZSBjb21wb25lbnRcbiAgICovXG4gIHByaXZhdGUgaW5pdCA9ICgpID0+IHtcbiAgICB0aGlzLmFwcGx5U3R5bGVzUnVsZXMoKTtcbiAgICB0aGlzLmFwcGVuZEluZmluaXRlQXV0b2NvbXBsZXRlV3JhcHBlckNsYXNzKCk7XG4gICAgdGhpcy5saW5rSW5wdXRDb21wb25lbnQoKTtcbiAgICB0aGlzLmxpbmtPcHRpb25zQ29tcG9uZW50KCk7XG4gICAgdGhpcy5iaW5kU2Nyb2xsUmVhY2hCb3R0b21FdmVudCgpO1xuICAgIHRoaXMuYmluZEVzY2FwZUV2ZW50KCk7XG4gICAgdGhpcy5iaW5kT3V0U2lkZUNsaWNrRXZlbnQoKTtcbiAgICB0aGlzLmlzRGVzdHJveWVkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogKCMxKSBCaW5kcyBhIGNsaWNrIGhhbmRsZXIgdG8gZGV0ZWN0IHdoZXJlIHRoZSB1c2VyIGNsaWNrZWRcbiAgICogSWYgY2xpY2sgaXMgb3V0IHNpZGUgdGhlIG1haW4gd3JhcHBlciBhcmVhIHRoZW4gY2xvc2Ugb3B0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBiaW5kT3V0U2lkZUNsaWNrRXZlbnQgPSAoKSA9PiB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihgY2xpY2tgLCB0aGlzLm9uRG9jdW1lbnRDbGlja0hhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIG9uIGRvY3VtZW50IGNsaWNrIGhhbmRsZXJcbiAgICogQHBhcmFtIGV2ZW50IC0gRXZlbnRcbiAgICovXG4gIHByaXZhdGUgb25Eb2N1bWVudENsaWNrSGFuZGxlciA9IChldmVudDogRXZlbnQpID0+IHtcbiAgICBpZiAoIXRoaXMuaXNPcHRpb25zSGlkZGVuKCkpIHtcbiAgICAgIGxldCBjbGlja2VkT3V0U2lkZSA9IHRoaXMuY2hlY2tJZkNsaWNrZWRPdXRTaWRlVGhlQXV0b2NvbXBsZXRlQ29tcG9uZW50cyhldmVudC50YXJnZXQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgaWYgKGNsaWNrZWRPdXRTaWRlKSB7XG4gICAgICAgICAgdGhpcy5jbGVhck9wdGlvbnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgY2xpY2sgaXMgb3V0c2lkZSB0aGUgcGx1Z2luXG4gICAqIEBwYXJhbSBlbGVtZW50IC0gSFRNTEVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgY2hlY2tJZkNsaWNrZWRPdXRTaWRlVGhlQXV0b2NvbXBsZXRlQ29tcG9uZW50cyA9IChlbGVtZW50OiBIVE1MRWxlbWVudCB8IG51bGwpID0+IHtcbiAgICBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2tJZkNsaWNrZWRPdXRTaWRlVGhlQXV0b2NvbXBsZXRlQ29tcG9uZW50cyhlbGVtZW50LnBhcmVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAoIzExKSBCaW5kcyBlc2NhcGUgZXZlbnQgaGFuZGxlciB0byBjbGVhciB0aGUgb3B0aW9ucyB3aGVuIGNsaWNraW5nIEVzY1xuICAgKi9cbiAgcHJpdmF0ZSBiaW5kRXNjYXBlRXZlbnQgPSAoKSA9PiB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy5vbkVzY2FwZUV2ZW50SGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogRXNjYXBlIGV2ZW50IGhhbmRsZXJcbiAgICogQHBhcmFtIGUgLSBLZXlib2FyZEV2ZW50XG4gICAqL1xuICBwcml2YXRlIG9uRXNjYXBlRXZlbnRIYW5kbGVyID0gZSA9PiB7XG4gICAgaWYgKGUua2V5Q29kZSA9PT0gMjcgJiYgIXRoaXMuaXNPcHRpb25zSGlkZGVuKCkpIHsgLy8gRXNjIGtleSBwcmVzc2VkXG4gICAgICAgIHRoaXMuY2xlYXJPcHRpb25zKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZCBpbmZpbml0ZSBhdXRvY29tcGxldGUgbWFpbiB3cmFwcGVyIGNsYXNzTmFtZVxuICAgKi9cbiAgcHJpdmF0ZSBhcHBlbmRJbmZpbml0ZUF1dG9jb21wbGV0ZVdyYXBwZXJDbGFzcyA9ICgpID0+IHtcbiAgICBpZiAoIXRoaXMuZWxlbWVudC5jbGFzc05hbWUgfHwgdGhpcy5lbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKGBpbmZpbml0ZS1hdXRvY29tcGxldGUtd3JhcHBlcmApID09PSAtMSkge1xuICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IHRoaXMuZWxlbWVudFxuICAgICAgICAuY2xhc3NOYW1lXG4gICAgICAgIC5zcGxpdChgIGApXG4gICAgICAgIC5jb25jYXQoW2BpbmZpbml0ZS1hdXRvY29tcGxldGUtd3JhcHBlcmBdKVxuICAgICAgICAuZmlsdGVyKGMgPT4gYylcbiAgICAgICAgLmpvaW4oYCBgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgY3VycmVudCBwYWdlXG4gICAqL1xuICBwcml2YXRlIHJlc2V0Q3VycmVudFBhZ2UgPSAoKSA9PiB7XG4gICAgdGhpcy5wYWdlID0gMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMaW5rIGlucHV0IGNvbXBvbmVudCBpbnRvIHRoZSBpbnB1dCB3cmFwcGVyXG4gICAqL1xuICBwcml2YXRlIGxpbmtJbnB1dENvbXBvbmVudCA9ICgpID0+IHtcbiAgICBjb25zdCBNaXNzaW5nSW5wdXRFbGVtZW50SW5JbnB1dENvbXBvbmVudEV4Y2VwdGlvbk1zZyA9XG4gICAgICBuZXcgRXJyb3IoYEN1c3RvbWl6ZWQgaW5wdXQgc2hvdWxkIGNvbnRhaW4gaW5wdXQgZWxlbWVudCA8aW5wdXQgLz5gKTtcbiAgICBsZXQgaW5wdXRXcmFwcGVyRWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChgZGl2YCk7XG4gICAgaW5wdXRXcmFwcGVyRWxlLmNsYXNzTmFtZSA9IGBpbmZpbml0ZS1hdXRvY29tcGxldGUtaW5wdXQtd3JhcHBlcmA7XG4gICAgaW5wdXRXcmFwcGVyRWxlLmlubmVySFRNTCA9IHRoaXMuaW5wdXRDb21wb25lbnQucmVuZGVyKCk7XG4gICAgbGV0IGlucHV0RWxlID0gaW5wdXRXcmFwcGVyRWxlLnF1ZXJ5U2VsZWN0b3IoYGlucHV0YCkgYXMgSFRNTEVsZW1lbnQ7XG4gICAgaWYgKCFpbnB1dEVsZSkge1xuICAgICAgVXRpbHMudGhyb3dFcnJvckluQ29uc29sZShNaXNzaW5nSW5wdXRFbGVtZW50SW5JbnB1dENvbXBvbmVudEV4Y2VwdGlvbk1zZyk7XG4gICAgICB0aHJvdyBNaXNzaW5nSW5wdXRFbGVtZW50SW5JbnB1dENvbXBvbmVudEV4Y2VwdGlvbk1zZztcbiAgICB9XG4gICAgaW5wdXRFbGVcbiAgICAgIC5hZGRFdmVudExpc3RlbmVyKGBpbnB1dGAsIHRoaXMub25JbnB1dENoYW5nZSk7XG4gICAgLy8gKCMyKSBTdGFydCB0byBzaG93IG9wdGlvbnMgd2hlbiBmb2N1cyBvbiB0aGUgaW5wdXRcbiAgICBpbnB1dEVsZVxuICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoYGNsaWNrYCwgdGhpcy5vbklucHV0Q2hhbmdlKTtcbiAgICBpbnB1dEVsZVxuICAgICAgLmFkZEV2ZW50TGlzdGVuZXIoYGtleWRvd25gLCB0aGlzLm9uS2V5UHJlc3NlZCk7XG4gICAgdGhpcy5lbGVtZW50LmFwcGVuZENoaWxkKGlucHV0V3JhcHBlckVsZSk7XG4gIH1cblxuICAvKipcbiAgICogT24ga2V5ZG93biBwcmVzc2luZyBpbiBpbnB1dCBlbGVtZW50XG4gICAqIEBwYXJhbSBrZXlkb3duRXZlbnQgLSBwcmVzc2luZyBrZXkgZXZlbnRcbiAgICovXG4gIHByaXZhdGUgb25LZXlQcmVzc2VkID0gKGtleWRvd25FdmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgIGlmICghdGhpcy5pc09wdGlvbnNIaWRkZW4oKSkge1xuICAgICAgbGV0IGN1cnJlbnRIb3ZlcmVkID0gdGhpcy5nZXROYXZpZ2F0aW9uSW5kZXgoKTtcbiAgICAgIGlmIChjdXJyZW50SG92ZXJlZCA9PT0gLTEpIHtcbiAgICAgICAgaWYgKGtleWRvd25FdmVudC5rZXlDb2RlID09PSBLRVlfUFJFU1NfU1RBVEVTLkRPV04pIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZUhvdmVyZWRTdGF0ZSgwLCBrZXlkb3duRXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKGtleWRvd25FdmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSBLRVlfUFJFU1NfU1RBVEVTLkRPV046XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhvdmVyZWRTdGF0ZShjdXJyZW50SG92ZXJlZCArIDEsIGtleWRvd25FdmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtFWV9QUkVTU19TVEFURVMuVVA6XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhvdmVyZWRTdGF0ZShjdXJyZW50SG92ZXJlZCAtIDEsIGtleWRvd25FdmVudCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIEtFWV9QUkVTU19TVEFURVMuRU5URVI6XG4gICAgICAgICAgICB0aGlzLmNsaWNrT25Ib3ZlcmVkKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xpY2sgb24gaG92ZXJlZCBlbGVtZW50XG4gICAqL1xuICBwcml2YXRlIGNsaWNrT25Ib3ZlcmVkID0gKCkgPT4ge1xuICAgIGxldCBvcHRpb25zTGlzdCA9IHRoaXMuZ2V0T3B0aW9uc0Jhc2VFbGVtZW50KCk7XG4gICAgbGV0IGhvdmVyZWRFbGVtZW50ID0gb3B0aW9uc0xpc3QucXVlcnlTZWxlY3RvcihgLiR7SE9WRVJFRH1gKSBhcyBIVE1MRWxlbWVudDtcbiAgICBpZiAoaG92ZXJlZEVsZW1lbnQpIHsgaG92ZXJlZEVsZW1lbnQuY2xpY2soKTsgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIFNjcm9sbGVkIHRvIGJvdHRvbVxuICAgKi9cbiAgcHJpdmF0ZSBzaW11bGF0ZVNjcm9sbFRvQm90dG9tID0gKCkgPT4ge1xuICAgIGxldCBvcHRpb25zTGlzdCA9IHRoaXMuZ2V0T3B0aW9uc0Jhc2VFbGVtZW50KCk7XG4gICAgbGV0IHNjcm9sbEV2ZW50ID0gbmV3IEV2ZW50KFwic2Nyb2xsXCIsIHsgYnViYmxlczogdHJ1ZSB9KTtcbiAgICBvcHRpb25zTGlzdC5zY3JvbGxUb3AgPSAxMDAwMDsgLy8gU2ltdWxhdGUgcmVhY2hlZCBib3R0b21cbiAgICBvcHRpb25zTGlzdC5kaXNwYXRjaEV2ZW50KHNjcm9sbEV2ZW50KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGUgaG92ZXJlZCBzdGF0ZSBvbiBzcGVjaWZpYyBpbmRleCBpbiBvcHRpb25zIGxpc3RcbiAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHRvIGJlIGFwcGxpZWQgYXMgaG92ZXJlZFxuICAgKi9cbiAgcHJpdmF0ZSB0b2dnbGVIb3ZlcmVkU3RhdGUgPSAoaW5kZXg6IG51bWJlciwga2V5ZG93bkV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgbGV0IG9wdGlvbnNMaXN0ID0gdGhpcy5nZXRPcHRpb25zQmFzZUVsZW1lbnQoKTtcbiAgICBpZiAoaW5kZXggPT09IG9wdGlvbnNMaXN0LmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdGhpcy5zaW11bGF0ZVNjcm9sbFRvQm90dG9tKCk7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBvcHRpb25zTGlzdC5jaGlsZHJlbi5sZW5ndGgpIHtcblxuICAgICAgbGV0IGhvdmVyZWRFbGVtZW50ID0gb3B0aW9uc0xpc3QucXVlcnlTZWxlY3RvcihgLiR7SE9WRVJFRH1gKTtcbiAgICAgIGlmIChob3ZlcmVkRWxlbWVudCkge1xuICAgICAgICBob3ZlcmVkRWxlbWVudC5jbGFzc05hbWUgPSBob3ZlcmVkRWxlbWVudFxuICAgICAgICAgIC5jbGFzc05hbWVcbiAgICAgICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IEhPVkVSRUQpXG4gICAgICAgICAgLmpvaW4oXCIgXCIpXG4gICAgICAgICAgLnRyaW0oKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHRhcmdldEVsZW1lbnQgPSBvcHRpb25zTGlzdC5jaGlsZHJlbltpbmRleF0gYXMgSFRNTEVsZW1lbnQ7XG4gICAgICB0YXJnZXRFbGVtZW50LmNsYXNzTmFtZSArPSBgICR7SE9WRVJFRH1gO1xuXG4gICAgICAvLyBJZiBob3ZlcmVkIGlzIG5vdCBpbiB0aGUgc2Nyb2xsYWJsZSB2aWV3XG4gICAgICBpZiAodGFyZ2V0RWxlbWVudC5vZmZzZXRUb3AgPCBvcHRpb25zTGlzdC5zY3JvbGxUb3AgfHwgKFxuICAgICAgICAgIHRhcmdldEVsZW1lbnQub2Zmc2V0VG9wIC0gb3B0aW9uc0xpc3Quc2Nyb2xsVG9wID4gb3B0aW9uc0xpc3QuY2xpZW50SGVpZ2h0KSkge1xuICAgICAgICBzd2l0Y2ggKGtleWRvd25FdmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgY2FzZSBLRVlfUFJFU1NfU1RBVEVTLlVQOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zY3JvbGxJbnRvVmlldyh0cnVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgS0VZX1BSRVNTX1NUQVRFUy5ET1dOOlxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zY3JvbGxJbnRvVmlldyhmYWxzZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgbmF2aWdhdGlvbiBpbmRleCBpZiBvcHRpb25zIGlzIG9wZW5cbiAgICogQHJldHVybnMgT3B0aW9ucyBjdXJyZW50IGluZGV4XG4gICAqL1xuICBwcml2YXRlIGdldE5hdmlnYXRpb25JbmRleCA9ICgpID0+IHtcbiAgICBsZXQgb3B0aW9uc0xpc3QgPSB0aGlzLmdldE9wdGlvbnNCYXNlRWxlbWVudCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3B0aW9uc0xpc3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBvcHRpb24gPSBvcHRpb25zTGlzdC5jaGlsZHJlbltpXTtcbiAgICAgIGlmIChvcHRpb24uY2xhc3NOYW1lLmluZGV4T2YoSE9WRVJFRCkgIT09IC0xKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnB1dCBjb21wb25lbnQgYGNoYW5nZWAgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0gaW5wdXRDaGFuZ2VFdmVudCAtIElucHV0IGNoYW5nZSBldmVudCBoYW5kbGVyXG4gICAqL1xuICBwcml2YXRlIG9uSW5wdXRDaGFuZ2UgPSAoaW5wdXRDaGFuZ2VFdmVudDogRXZlbnQpID0+IHtcbiAgICBsZXQgdGFyZ2V0ID0gaW5wdXRDaGFuZ2VFdmVudC5jdXJyZW50VGFyZ2V0IGFzIEhUTUxJbnB1dEVsZW1lbnQ7XG4gICAgLy8gSWYgdXNlciBwYXNzIHNwZWNpYWwgYmVoYXZpb3IgZm9yIHR5cGluZyB2aWEgY29uZmlndXJhdGlvblxuICAgIGlmICh0aGlzLmlucHV0Q29tcG9uZW50Lm9uSW5wdXRDaGFuZ2UpIHtcbiAgICAgIHRoaXMuaW5wdXRDb21wb25lbnQub25JbnB1dENoYW5nZSh0YXJnZXQsIHRhcmdldC52YWx1ZSk7XG4gICAgfVxuICAgIC8vIElmIHdlIHR5cGUgYWx3YXlzIGZldGNoIGRhdGEgYW5kIGJ1aWxkIG9wdGlvbnNcbiAgICAvLyBJZiB3ZSBjbGljayBvbiBpbnB1dCBhbmQgdGhlIG9wdGlvbnMgaXMgaGlkZGVuIGJ1aWxkIHRoZSBvcHRpb25zXG4gICAgLy8gSWYgd2UgY2xpY2sgb24gaW5wdXQgYW5kIHRoZSBvcHRpb25zIGlzIGFscmVhZHkgb3BlbmVkIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKGlucHV0Q2hhbmdlRXZlbnQudHlwZSA9PT0gYGlucHV0YCB8fFxuICAgICAgICAgICAgKGlucHV0Q2hhbmdlRXZlbnQudHlwZSA9PT0gYGNsaWNrYCAmJiB0aGlzLmlzT3B0aW9uc0hpZGRlbigpKSkge1xuICAgICAgdGhpcy5idWlsZE9wdGlvbnModGFyZ2V0LnZhbHVlLCB0cnVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTGluayBvcHRpb25zIGNvbXBvbmVudCBpbnRvIHRoZSBpbmZpbml0ZSBhdXRvY29tcGxldGUgY29tcG9uZW50XG4gICAqL1xuICBwcml2YXRlIGxpbmtPcHRpb25zQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgIGxldCBvcHRpb25zV3JhcHBlckVsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYGRpdmApO1xuICAgIG9wdGlvbnNXcmFwcGVyRWxlLmNsYXNzTmFtZSA9IGBpbmZpbml0ZS1hdXRvY29tcGxldGUtb3B0aW9ucy13cmFwcGVyYDtcbiAgICBvcHRpb25zV3JhcHBlckVsZS5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnNDb21wb25lbnQucmVuZGVyKCk7XG4gICAgbGV0IG9wdGlvbnNFbGUgPSBvcHRpb25zV3JhcHBlckVsZS5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9uc0NvbXBvbmVudC5saXN0RWxlbWVudFNlbGVjdG9yKSBhcyBIVE1MRWxlbWVudDtcbiAgICB0aGlzLnNldEVsZW1lbnRWaXNpYmxpdHkob3B0aW9uc1dyYXBwZXJFbGUsIGZhbHNlKTtcbiAgICBvcHRpb25zRWxlLnN0eWxlLm92ZXJmbG93ID0gYHNjcm9sbGA7XG4gICAgb3B0aW9uc0VsZS5zdHlsZS5vdmVyZmxvd1ggPSBgaGlkZGVuYDtcbiAgICBvcHRpb25zRWxlLnN0eWxlLmJvcmRlciA9IGAxcHggc29saWQgI2JjYmNiY2A7XG4gICAgb3B0aW9uc0VsZS5zdHlsZS5wYWRkaW5nQm90dG9tID0gYDVweGA7XG4gICAgb3B0aW9uc0VsZS5zdHlsZS5tYXhIZWlnaHQgPSB0aGlzLmNvbmZpZy5tYXhIZWlnaHQgfHwgbnVsbDtcbiAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQob3B0aW9uc1dyYXBwZXJFbGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIG9wdGlvbnMgd3JhcHBlciBoaWRkZW4gb3Igbm90XG4gICAqIEByZXR1cm5zIHRydWUgaWYgaGlkZGVuLCBvciBlbHNlIGZhbHNlXG4gICAqL1xuICBwcml2YXRlIGlzT3B0aW9uc0hpZGRlbiA9ICgpOiBib29sZWFuID0+IHtcbiAgICBsZXQgb3B0aW9uc1dyYXBwZXIgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLmluZmluaXRlLWF1dG9jb21wbGV0ZS1vcHRpb25zLXdyYXBwZXJgKSBhcyBIVE1MRWxlbWVudDtcblxuICAgIHJldHVybiBvcHRpb25zV3JhcHBlci5jbGFzc05hbWVcbiAgICAgIC5pbmRleE9mKGBpbmZpbml0ZS1hdXRvY29tcGxldGUtaGlkZGVuLWVsZW1lbnRgKSA+IC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5IHRoZSBzdHlsZSBydWxlcyBmb3IgdGhlIGluZmluaXRlIGF1dG9jb21wbGV0ZSBwbHVnaW4gYW5kIGl0J3MgY29tcG9uZW50c1xuICAgKi9cbiAgcHJpdmF0ZSBhcHBseVN0eWxlc1J1bGVzID0gKCkgPT4ge1xuXG4gICAgLy8gTWFpbiB3cmFwcGVyIHN0eWxlIHJ1bGVzXG4gICAgbGV0IGlzTWFpbldyYXBwZXJTdHlsZUFwcGxpZWQgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCIjaW5maW5pdGUtYXV0b2NvbXBsZXRlLXdyYXBwZXItc3R5bGVcIik7XG4gICAgaWYgKCFpc01haW5XcmFwcGVyU3R5bGVBcHBsaWVkKSB7XG4gICAgICBsZXQgbWFpbldyYXBwZXJTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgIG1haW5XcmFwcGVyU3R5bGUuaWQgPSBcImluZmluaXRlLWF1dG9jb21wbGV0ZS13cmFwcGVyLXN0eWxlXCI7XG4gICAgICBtYWluV3JhcHBlclN0eWxlLmlubmVySFRNTCA9IGBcbiAgICAgICAgICAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLXdyYXBwZXIge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgICAgfVxuICAgICAgYDtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobWFpbldyYXBwZXJTdHlsZSk7XG4gICAgfVxuXG4gICAgLy8gSGlkZGVuIGVsZW1lbnQgc3R5bGUgcnVsZXNcbiAgICBsZXQgaXNIaWRkZW5TdHlsZUFwcGxpZWQgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCIjaW5maW5pdGUtYXV0b2NvbXBsZXRlLWhpZGRlbi1zdHlsZVwiKTtcbiAgICBpZiAoIWlzSGlkZGVuU3R5bGVBcHBsaWVkKSB7XG4gICAgICBsZXQgaGlkZGVuU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBoaWRkZW5TdHlsZS5pZCA9IFwiaW5maW5pdGUtYXV0b2NvbXBsZXRlLWhpZGRlbi1zdHlsZVwiO1xuICAgICAgaGlkZGVuU3R5bGUuaW5uZXJIVE1MID0gYFxuICAgICAgICAgIC5pbmZpbml0ZS1hdXRvY29tcGxldGUtaGlkZGVuLWVsZW1lbnQge1xuICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICAgICAgICAgIHotaW5kZXg6IC0xO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGhpZGRlblN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0cyBzdHlsZSBydWxlc1xuICAgIGxldCBpc0RlZmF1bHRzU3R5bGVBcHBsaWVkID0gZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKFwiI2luZmluaXRlLWF1dG9jb21wbGV0ZS1kZWZhdWx0cy1zdHlsZVwiKTtcbiAgICBpZiAoIWlzRGVmYXVsdHNTdHlsZUFwcGxpZWQpIHtcbiAgICAgIGxldCBkZWZhdWx0c1N0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgZGVmYXVsdHNTdHlsZS5pZCA9IFwiaW5maW5pdGUtYXV0b2NvbXBsZXRlLWRlZmF1bHRzLXN0eWxlXCI7XG4gICAgICBkZWZhdWx0c1N0eWxlLmlubmVySFRNTCA9IGBcbiAgICAgICAgICAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLWlucHV0LXdyYXBwZXIgLmluZmluaXRlLWF1dG9jb21wbGV0ZS1kZWZhdWx0LWlucHV0IHtcbiAgICAgICAgICAgICAgaGVpZ2h0OiAyOHB4O1xuICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgICAgICAgIGJveC1zaGFkb3c6IGluc2V0IDBweCAwcHggMTVweCAtNHB4IHRyYW5zcGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLW9wdGlvbnMtd3JhcHBlciAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLWRlZmF1bHQtb3B0aW9ucyB7XG4gICAgICAgICAgICAgIGxpc3Qtc3R5bGUtdHlwZTogbm9uZTtcbiAgICAgICAgICAgICAgbWFyZ2luLXRvcDogMDtcbiAgICAgICAgICAgICAgcGFkZGluZy1sZWZ0OiAwO1xuICAgICAgICAgICAgICBtYXJnaW4tYm90dG9tOiAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLW9wdGlvbnMtd3JhcHBlciAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLWRlZmF1bHQtb3B0aW9ucyBsaSB7XG4gICAgICAgICAgICAgIHBhZGRpbmc6IDVweCAxMHB4IDEwcHggMTBweDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLmluZmluaXRlLWF1dG9jb21wbGV0ZS1vcHRpb25zLXdyYXBwZXIgLmluZmluaXRlLWF1dG9jb21wbGV0ZS1kZWZhdWx0LW9wdGlvbnMgbGkuaG92ZXJlZCB7XG4gICAgICAgICAgICAgIGJhY2tncm91bmQ6ICNkNWViZmY7XG4gICAgICAgICAgICAgIGNvbG9yOiBibGFjaztcbiAgICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGRlZmF1bHRzU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIElucHV0IHN0eWxlIHJ1bGVzXG4gICAgbGV0IGlzSW5wdXRTdHlsZUFwcGxpZWQgPSBkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoXCIjaW5maW5pdGUtYXV0b2NvbXBsZXRlLWlucHV0LXN0eWxlXCIpO1xuICAgIGlmICghaXNJbnB1dFN0eWxlQXBwbGllZCkge1xuICAgICAgbGV0IGlucHV0U3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICBpbnB1dFN0eWxlLmlkID0gXCJpbmZpbml0ZS1hdXRvY29tcGxldGUtaW5wdXQtc3R5bGVcIjtcbiAgICAgIGlucHV0U3R5bGUuaW5uZXJIVE1MID0gYFxuICAgICAgICAgIC5pbmZpbml0ZS1hdXRvY29tcGxldGUtaW5wdXQtd3JhcHBlciBpbnB1dCB7XG4gICAgICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIH1cbiAgICAgIGA7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGlucHV0U3R5bGUpO1xuICAgIH1cblxuICAgIC8vIE9wdGlvbnMgc3R5bGUgcnVsZXNcbiAgICBsZXQgaXNPcHRpb25zU3R5bGVBcHBsaWVkID0gZG9jdW1lbnQuaGVhZC5xdWVyeVNlbGVjdG9yKFwiI2luZmluaXRlLWF1dG9jb21wbGV0ZS1vcHRpb25zLXN0eWxlXCIpO1xuICAgIGlmICghaXNPcHRpb25zU3R5bGVBcHBsaWVkKSB7XG4gICAgICBsZXQgb3B0aW9uc1N0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgb3B0aW9uc1N0eWxlLmlkID0gYGluZmluaXRlLWF1dG9jb21wbGV0ZS1vcHRpb25zLXN0eWxlYDtcbiAgICAgIG9wdGlvbnNTdHlsZS5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgLmluZmluaXRlLWF1dG9jb21wbGV0ZS1vcHRpb25zLXdyYXBwZXIge1xuICAgICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICAgIHotaW5kZXg6IDEwO1xuICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB3aGl0ZTtcbiAgICAgICAgICB9XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChvcHRpb25zU3R5bGUpO1xuICAgIH1cblxuICAgIC8vIFNjcm9sbGJhciBzdHlsZSBydWxlc1xuICAgIGxldCBpc1Njcm9sbGJhclN0eWxlQXBwbGllZCA9IGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcihcIiNpbmZpbml0ZS1hdXRvY29tcGxldGUtc2Nyb2xsYmFyLXN0eWxlXCIpO1xuICAgIGlmICghaXNTY3JvbGxiYXJTdHlsZUFwcGxpZWQpIHtcbiAgICAgIGxldCBzcGVjaWFsU2Nyb2xsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICAgICAgc3BlY2lhbFNjcm9sbC5pZCA9IFwiaW5maW5pdGUtYXV0b2NvbXBsZXRlLXNjcm9sbGJhci1zdHlsZVwiO1xuICAgICAgc3BlY2lhbFNjcm9sbC5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgLmluZmluaXRlLWF1dG9jb21wbGV0ZS13cmFwcGVyIDo6LXdlYmtpdC1zY3JvbGxiYXIge1xuICAgICAgICAgICAgICAgICAgd2lkdGg6IDRweDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC5pbmZpbml0ZS1hdXRvY29tcGxldGUtd3JhcHBlciA6Oi13ZWJraXQtc2Nyb2xsYmFyLXRyYWNrIHtcbiAgICAgICAgICAgICAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAwIDZweCByZ2JhKDAsMCwwLDAuMyk7XG4gICAgICAgICAgICAgICAgICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDEwcHg7XG4gICAgICAgICAgICAgICAgICBib3JkZXItcmFkaXVzOiAxMHB4O1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLmluZmluaXRlLWF1dG9jb21wbGV0ZS13cmFwcGVyIDo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xuICAgICAgICAgICAgICAgICAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAxMHB4O1xuICAgICAgICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogMTBweDtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC44KTtcbiAgICAgICAgICAgICAgICAgIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAwIDZweCByZ2JhKDAsMCwwLDAuNSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLmluZmluaXRlLWF1dG9jb21wbGV0ZS13cmFwcGVyIDo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWI6d2luZG93LWluYWN0aXZlIHtcbiAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJnYmEoMjU1LDAsMCwwLjQpO1xuICAgICAgICAgICAgICB9XG4gICAgICBgO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzcGVjaWFsU2Nyb2xsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQmluZHMgYSBzY3JvbGwgZXZlbnQgaGFuZGxlciBvbiB0aGUgb3B0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBiaW5kU2Nyb2xsUmVhY2hCb3R0b21FdmVudCA9ICgpID0+IHtcbiAgICBsZXQgb3B0aW9uc0VsZSA9IHRoaXMuZ2V0T3B0aW9uc0Jhc2VFbGVtZW50KCk7XG4gICAgb3B0aW9uc0VsZS5hZGRFdmVudExpc3RlbmVyKGBzY3JvbGxgLCB0aGlzLnNjcm9sbFJlYWNoZWRCb3R0b21IYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTY3JvbGwgcmVhY2hlZCBib3R0b20gaGFuZGxlclxuICAgKiBAcGFyYW0gZSAtIFNjcm9sbCBldmVudCBvYmplY3RcbiAgICovXG4gIHByaXZhdGUgc2Nyb2xsUmVhY2hlZEJvdHRvbUhhbmRsZXIgPSAoZTogRXZlbnQpID0+IHtcbiAgICBsZXQgb3B0aW9uc0VsZSA9IGUuY3VycmVudFRhcmdldCBhcyBIVE1MRWxlbWVudDtcbiAgICBpZiAoIXRoaXMuZmV0Y2hpbmdEYXRhICYmICF0aGlzLnByZXZlbnRNb3JlUmVxdWVzdHMgJiYgIXRoaXMuaXNPcHRpb25zSGlkZGVuKCkpIHtcbiAgICAgIGlmIChvcHRpb25zRWxlLnNjcm9sbFRvcCArIG9wdGlvbnNFbGUuY2xpZW50SGVpZ2h0ID49IG9wdGlvbnNFbGUuc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICAgIHRoaXMucGFnZSsrO1xuICAgICAgICB0aGlzLmJ1aWxkT3B0aW9ucyhcbiAgICAgICAgICAgIHRoaXMuZ2V0SW5wdXRFbGVtZW50KCkudmFsdWUsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBvcHRpb25zIGxpc3QgdGFnIHdpdGggcmVtb3ZpbmcgdGhlIGNsaWNrIGV2ZW50IGhhbmRsZXJzXG4gICAqIHVuYmluZCB0aGUgYHNjcm9sbGAgZXZlbnQgZnJvbSB0aGUgb3B0aW9uc1xuICAgKiAoR2FyYmFnZSBjb2xsZWN0aW5nKVxuICAgKi9cbiAgcHJpdmF0ZSBjbGVhck9wdGlvbnMgPSAoKSA9PiB7XG4gICAgdGhpcy5kZXRhY2hPcHRpb25FdmVudEhhbmRsZXJzKFxuICAgICAgdGhpcy5nZXRPcHRpb25zQmFzZUVsZW1lbnQoKVxuICAgICAgICAucXVlcnlTZWxlY3RvckFsbChgW2luZmluaXRlLWNsaWNrYWJsZV1gKSxcbiAgICApO1xuICAgIHRoaXMucmVzZXRDdXJyZW50UGFnZSgpO1xuICAgIHRoaXMucHJldmVudE1vcmVSZXF1ZXN0cyA9IGZhbHNlO1xuXG4gICAgbGV0IG9wdGlvbkxpc3RFbGVtZW50ID0gdGhpcy5nZXRPcHRpb25zQmFzZUVsZW1lbnQoKTtcblxuICAgIHRoaXMuc2V0RWxlbWVudFZpc2libGl0eShcbiAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLW9wdGlvbnMtd3JhcHBlcmApIGFzIEhUTUxFbGVtZW50LFxuICAgICAgZmFsc2UsXG4gICAgKTtcbiAgICBvcHRpb25MaXN0RWxlbWVudC5pbm5lckhUTUwgPSBgYDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBlbGVtZW50IHZpc2libGl0eVxuICAgKiBAcGFyYW0gZWxlbWVudCAtIEhUTUxFbGVtZW50XG4gICAqIEBwYXJhbSB2aXNpYmxlIC0gdmlzaWJpbGl0eSBzdGF0dXNcbiAgICovXG4gIHByaXZhdGUgc2V0RWxlbWVudFZpc2libGl0eShlbGVtZW50OiBIVE1MRWxlbWVudCwgdmlzaWJsZTogYm9vbGVhbikge1xuICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICBlbGVtZW50LmNsYXNzTmFtZSA9IGVsZW1lbnQuY2xhc3NOYW1lXG4gICAgICAgIC5zcGxpdChcIiBcIilcbiAgICAgICAgLmZpbHRlcihlID0+IGUgIT09IGBpbmZpbml0ZS1hdXRvY29tcGxldGUtaGlkZGVuLWVsZW1lbnRgKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTmFtZS5pbmRleE9mKGBpbmZpbml0ZS1hdXRvY29tcGxldGUtaGlkZGVuLWVsZW1lbnRgKSA9PT0gLTEpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc05hbWUgKz0gYCBpbmZpbml0ZS1hdXRvY29tcGxldGUtaGlkZGVuLWVsZW1lbnRgO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgb3B0aW9ucyBiYXNlIEhUTUxFbGVtZW50XG4gICAqIEByZXR1cm5zIEhUTUxFbGVtZW50XG4gICAqL1xuICBwcml2YXRlIGdldE9wdGlvbnNCYXNlRWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgY29uc3Qgb3B0aW9uc1dyYXBwZXJFeGNlcHRpb25Nc2cgPSBuZXcgRXJyb3IoYENvdWxkbid0IGdldCB0aGUgb3B0aW9ucyBiYXNlIGVsZW1lbnQuYCk7XG4gICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgbGV0IG9wdGlvbnNXcmFwcGVyID0gdGhpcy5lbGVtZW50XG4gICAgICAgIC5xdWVyeVNlbGVjdG9yKGAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLW9wdGlvbnMtd3JhcHBlcmApO1xuICAgICAgaWYgKG9wdGlvbnNXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zV3JhcHBlclxuICAgICAgICAgIC5xdWVyeVNlbGVjdG9yKHRoaXMub3B0aW9uc0NvbXBvbmVudC5saXN0RWxlbWVudFNlbGVjdG9yKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWxzLnRocm93RXJyb3JJbkNvbnNvbGUob3B0aW9uc1dyYXBwZXJFeGNlcHRpb25Nc2cpO1xuICAgICAgICB0aHJvdyBvcHRpb25zV3JhcHBlckV4Y2VwdGlvbk1zZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMudGhyb3dFcnJvckluQ29uc29sZShvcHRpb25zV3JhcHBlckV4Y2VwdGlvbk1zZyk7XG4gICAgICB0aHJvdyBvcHRpb25zV3JhcHBlckV4Y2VwdGlvbk1zZztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0YWNoaW5nIHRoZSBldmVudCBoYW5kbGVycyBvdmVyIHRoZSBvcHRpb24gZWxlbWVudHNcbiAgICovXG4gIHByaXZhdGUgZGV0YWNoT3B0aW9uRXZlbnRIYW5kbGVycyhlbGVtZW50czogTm9kZUxpc3RPZjxFbGVtZW50Pikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGVsZW1lbnRzW2ldLnJlbW92ZUV2ZW50TGlzdGVuZXIoYGNsaWNrYCwgdGhpcy5vbk9wdGlvbkNsaWNrRXZlbnQpO1xuICAgICAgZWxlbWVudHNbaV0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihgbW91c2VvdmVyYCwgdGhpcy5vbk9wdGlvbkhvdmVyRXZlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBPcHRpb24gY2xpY2sgZXZlbnQgaGFuZGxlclxuICAgKiBAcGFyYW0gY2xpY2tFdmVudFxuICAgKi9cbiAgcHJpdmF0ZSBvbk9wdGlvbkNsaWNrRXZlbnQgPSAoY2xpY2tFdmVudDogTW91c2VFdmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmNvbmZpZy5vblNlbGVjdCkge1xuICAgICAgdGhpcy5jb25maWcub25TZWxlY3QoY2xpY2tFdmVudC5jdXJyZW50VGFyZ2V0LCAoY2xpY2tFdmVudC5jdXJyZW50VGFyZ2V0IGFzIGFueSkuZGF0YSk7XG4gICAgfVxuICAgIHRoaXMuY2xlYXJPcHRpb25zKCk7XG4gICAgdGhpcy5zZXRJbnB1dCgoY2xpY2tFdmVudC5jdXJyZW50VGFyZ2V0IGFzIGFueSkuZGF0YS50ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgaW5wdXQgSFRNTCBlbGVtZW50IGJlbG93IGluZmluaXRlLWF1dG9jb21wbGV0ZS1pbnB1dC13cmFwcGVyXG4gICAqIEByZXR1cm5zIEhUTUxJbnB1dEVsZW1lbnRcbiAgICovXG4gIHByaXZhdGUgZ2V0SW5wdXRFbGVtZW50KCk6IEhUTUxJbnB1dEVsZW1lbnQge1xuICAgIGNvbnN0IGlucHV0RWxlbWVudEV4Y2VwdGlvbk1zZyA9IG5ldyBFcnJvcihgQ291bGRuJ3QgZ2V0IHRoZSBpbnB1dCBlbGVtZW50LmApO1xuICAgIGlmICh0aGlzLmVsZW1lbnQpIHtcbiAgICAgIGxldCBpbnB1dFdyYXBwZXIgPSB0aGlzLmVsZW1lbnRcbiAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoYC5pbmZpbml0ZS1hdXRvY29tcGxldGUtaW5wdXQtd3JhcHBlcmApO1xuICAgICAgaWYgKGlucHV0V3JhcHBlcikge1xuICAgICAgICByZXR1cm4gaW5wdXRXcmFwcGVyXG4gICAgICAgICAgLnF1ZXJ5U2VsZWN0b3IoYGlucHV0YCkgYXMgSFRNTElucHV0RWxlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFV0aWxzLnRocm93RXJyb3JJbkNvbnNvbGUoaW5wdXRFbGVtZW50RXhjZXB0aW9uTXNnKTtcbiAgICAgICAgdGhyb3cgaW5wdXRFbGVtZW50RXhjZXB0aW9uTXNnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBVdGlscy50aHJvd0Vycm9ySW5Db25zb2xlKGlucHV0RWxlbWVudEV4Y2VwdGlvbk1zZyk7XG4gICAgICB0aHJvdyBpbnB1dEVsZW1lbnRFeGNlcHRpb25Nc2c7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBpbnB1dCBzaG93biB0ZXh0XG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqL1xuICBwcml2YXRlIHNldElucHV0KHRleHQ6IHN0cmluZykge1xuICAgIHRoaXMuZ2V0SW5wdXRFbGVtZW50KClcbiAgICAgIC52YWx1ZSA9IHRleHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGRhdGEgYmFzZWQgb24gdGV4dCwgcGFnZSBhbmQgZmV0Y2hTaXplXG4gICAqIEBwYXJhbSB0ZXh0XG4gICAqIEBwYXJhbSBwYWdlXG4gICAqIEBwYXJhbSBmZXRjaFNpemVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZ2V0RGF0YSh0ZXh0OiBzdHJpbmcsIHBhZ2U6IG51bWJlciwgZmV0Y2hTaXplOiBudW1iZXIpOiBQcm9taXNlPElPcHRpb25bXSB8IG51bGw+IHtcbiAgICB0aGlzLnNlYXJjaGVkVGV4dCA9IHRleHQ7XG4gICAgY29uc3QgZGF0YVNvdXJjZU1pc3NpbmdFeGNlcHRpb25Nc2cgPSBuZXcgRXJyb3IgKGBZb3UgbXVzdCBwYXNzIGRhdGEgb3IgZ2V0RGF0YUZyb21BcGkgZnVuY3Rpb24gdmlhIGNvbmZpZ2ApO1xuICAgIGlmICh0aGlzLmNvbmZpZy5kYXRhKSB7XG4gICAgICB0aGlzLmZldGNoaW5nRGF0YSA9IHRydWU7XG4gICAgICBsZXQgZnJvbSA9IChwYWdlIC0gMSkgKiBmZXRjaFNpemU7XG4gICAgICBsZXQgdG8gPSAoZmV0Y2hTaXplICogKHBhZ2UgLSAxKSkgKyBmZXRjaFNpemU7XG4gICAgICBsZXQgc3RhdGljRGF0YSA9IHRoaXMuY29uZmlnLmRhdGFcbiAgICAgICAgICAuZmlsdGVyKG9wdGlvbiA9PiBvcHRpb24udGV4dC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodGV4dC50b0xvd2VyQ2FzZSgpKSAhPT0gLTEpXG4gICAgICAgICAgLnNsaWNlKGZyb20sIHRvKTtcbiAgICAgIHRoaXMuZmV0Y2hpbmdEYXRhID0gZmFsc2U7XG5cbiAgICAgIHJldHVybiBzdGF0aWNEYXRhO1xuICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuZ2V0RGF0YUZyb21BcGkpIHtcbiAgICAgIHRoaXMuZmV0Y2hpbmdEYXRhID0gdHJ1ZTtcbiAgICAgIGxldCBhcGlEYXRhID0gYXdhaXQgdGhpcy5jb25maWcuZ2V0RGF0YUZyb21BcGkodGV4dCwgcGFnZSwgZmV0Y2hTaXplKTtcbiAgICAgIHRoaXMuZmV0Y2hpbmdEYXRhID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuc2VhcmNoZWRUZXh0ID09PSB0ZXh0ICYmXG4gICAgICAgIHRoaXMucGFnZSA9PT0gcGFnZSAmJlxuICAgICAgICB0aGlzLmNvbmZpZy5mZXRjaFNpemUgPT09IGZldGNoU2l6ZVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBhcGlEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIFV0aWxzLnRocm93RXJyb3JJbkNvbnNvbGUoZGF0YVNvdXJjZU1pc3NpbmdFeGNlcHRpb25Nc2cpO1xuICAgICAgdGhyb3cgZGF0YVNvdXJjZU1pc3NpbmdFeGNlcHRpb25Nc2c7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9uIGhvdmVyaW5nIG9uIG9wdGlvbiByb3dcbiAgICogQHBhcmFtIGV2ZW50IC0gSG92ZXIgTW91c2UgRXZlbnRcbiAgICovXG4gIHByaXZhdGUgb25PcHRpb25Ib3ZlckV2ZW50ID0gKGV2ZW50OiBNb3VzZUV2ZW50KSA9PiB7XG4gICAgbGV0IG9wdGlvbnNMaXN0ID0gdGhpcy5nZXRPcHRpb25zQmFzZUVsZW1lbnQoKTtcbiAgICBsZXQgaG92ZXJlZEVsZW1lbnQgPSBvcHRpb25zTGlzdC5xdWVyeVNlbGVjdG9yKGAuJHtIT1ZFUkVEfWApO1xuICAgIGlmIChob3ZlcmVkRWxlbWVudCkge1xuICAgICAgaG92ZXJlZEVsZW1lbnQuY2xhc3NOYW1lID0gaG92ZXJlZEVsZW1lbnRcbiAgICAgICAgLmNsYXNzTmFtZVxuICAgICAgICAuc3BsaXQoXCIgXCIpXG4gICAgICAgIC5maWx0ZXIoZSA9PiBlICE9PSBIT1ZFUkVEKVxuICAgICAgICAuam9pbihcIiBcIilcbiAgICAgICAgLnRyaW0oKTtcbiAgICB9XG4gICAgbGV0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQ7XG4gICAgdGFyZ2V0LmNsYXNzTmFtZSArPSBgICR7SE9WRVJFRH1gO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBvcHRpb25zIGlubmVyIHRhZ3MgaW4gb3B0aW9ucyBsaXN0IHRhZyBiYXNlZCBvbiB0aGUgdGV4dCBwYXNzZWQgYW5kIHRoZSBkYXRhIGluIGNvbmZpZ1xuICAgKiBAcGFyYW0gdGV4dCAtIFRleHQgdG8gc2VhcmNoIG9uIGluIHRoZSBhdXRvY29tcGxldGVcbiAgICogQHBhcmFtIGNsZWFyUHJldmlvdXNEYXRhIC0gRmxhZyB0byBjbGVhciBwcmV2aW91cyBvcHRpb25zIGFuZCBvdmVycmlkZSB3aXRoIHRoZSBuZXcgb25lXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGJ1aWxkT3B0aW9ucyh0ZXh0OiBzdHJpbmcsIGNsZWFyUHJldmlvdXNEYXRhOiBib29sZWFuID0gdHJ1ZSk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGZldGNoU2l6ZUV4Y2VwdGlvbk1zZyA9IG5ldyBFcnJvcihgZmV0Y2hTaXplIG11c3QgYmUgb3ZlcnJpZGVuIHdpdGggY29ycmVjdCBudW1lcmljIHZhbHVlYCk7XG5cbiAgICBsZXQgb3B0aW9uTGlzdEVsZW1lbnQgPSB0aGlzLmdldE9wdGlvbnNCYXNlRWxlbWVudCgpO1xuICAgIGlmIChjbGVhclByZXZpb3VzRGF0YSkge1xuICAgICAgICB0aGlzLmNsZWFyT3B0aW9ucygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNvbmZpZy5mZXRjaFNpemUpIHtcbiAgICAgIGxldCBmaWx0ZXJlZE9wdGlvbnMgPSBhd2FpdCB0aGlzLmdldERhdGEodGV4dCwgdGhpcy5wYWdlLCB0aGlzLmNvbmZpZy5mZXRjaFNpemUpO1xuXG4gICAgICBpZiAoZmlsdGVyZWRPcHRpb25zICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoIDwgdGhpcy5jb25maWcuZmV0Y2hTaXplKSB7XG4gICAgICAgICAgLy8gU3RvcCBmZXRjaGluZyBtb3JlIGNodW5rcyB3aGVuZXZlciB5b3UgZ2V0IGxlc3MgdGhhbiB0aGUgY2h1bmsgZmV0Y2ggc2l6ZVxuICAgICAgICAgIHRoaXMucHJldmVudE1vcmVSZXF1ZXN0cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXJlZE9wdGlvbnNcbiAgICAgICAgICAuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICAgICAgbGV0IG9wdGlvbkVsZW1lbnRUZW1wbGF0ZSA9IHRoaXMub3B0aW9uc0NvbXBvbmVudC5yZW5kZXJPcHRpb24ob3B0aW9uKTtcbiAgICAgICAgICAgIGxldCB0ZW1wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYGRpdmApO1xuICAgICAgICAgICAgdGVtcEVsZW1lbnQuaW5uZXJIVE1MID0gb3B0aW9uRWxlbWVudFRlbXBsYXRlO1xuICAgICAgICAgICAgbGV0IG9wdGlvbkVsZW1lbnQgPSB0ZW1wRWxlbWVudC5jaGlsZE5vZGVzWzBdO1xuICAgICAgICAgICAgKG9wdGlvbkVsZW1lbnQgYXMgYW55KS5kYXRhID0geyB0ZXh0OiBvcHRpb24udGV4dCwgdmFsdWU6IG9wdGlvbi52YWx1ZSB9O1xuICAgICAgICAgICAgKG9wdGlvbkVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpLnNldEF0dHJpYnV0ZShcImluZmluaXRlLWNsaWNrYWJsZVwiLCBcIlwiKTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihgY2xpY2tgLCB0aGlzLm9uT3B0aW9uQ2xpY2tFdmVudCk7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYG1vdXNlb3ZlcmAsIHRoaXMub25PcHRpb25Ib3ZlckV2ZW50KTtcbiAgICAgICAgICAgIG9wdGlvbkxpc3RFbGVtZW50LmFwcGVuZENoaWxkKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmaWx0ZXJlZE9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGxldCBjaHVua0NsaWVudEhlaWdodCA9IG9wdGlvbkxpc3RFbGVtZW50LmNoaWxkcmVuWzBdLmNsaWVudEhlaWdodDtcbiAgICAgICAgICAvLyBDaGVjayBpZiBtYXhIZWlnaHQgaXMgZml0cyB0aGUgY2h1bmsgc2l6ZSBsaXN0XG4gICAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1heEhlaWdodCkge1xuICAgICAgICAgICAgbGV0IG1heEhlaWdodE51bWJlciA9IHBhcnNlSW50KHRoaXMuY29uZmlnLm1heEhlaWdodCwgMTApO1xuICAgICAgICAgICAgaWYgKG1heEhlaWdodE51bWJlciA+PSBjaHVua0NsaWVudEhlaWdodCAqIHRoaXMuY29uZmlnLmZldGNoU2l6ZSkge1xuICAgICAgICAgICAgICB0aGlzLmNvbmZpZy5tYXhIZWlnaHQgPSAoY2h1bmtDbGllbnRIZWlnaHQgKiB0aGlzLmNvbmZpZy5mZXRjaFNpemUgLSA1KSArIFwicHhcIjtcbiAgICAgICAgICAgICAgbGV0IG9wdGlvbnNXcmFwcGVyRWxlID1cbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLmluZmluaXRlLWF1dG9jb21wbGV0ZS1vcHRpb25zLXdyYXBwZXJgKSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgICAgICAgbGV0IG9wdGlvbnNFbGUgPVxuICAgICAgICAgICAgICAgIG9wdGlvbnNXcmFwcGVyRWxlLnF1ZXJ5U2VsZWN0b3IodGhpcy5vcHRpb25zQ29tcG9uZW50Lmxpc3RFbGVtZW50U2VsZWN0b3IpIGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgICBvcHRpb25zRWxlLnN0eWxlLm1heEhlaWdodCA9IHRoaXMuY29uZmlnLm1heEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG9wdGlvbkxpc3RFbGVtZW50LmlubmVySFRNTCAhPT0gYGApIHtcbiAgICAgICAgdGhpcy5zZXRFbGVtZW50VmlzaWJsaXR5KFxuICAgICAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuaW5maW5pdGUtYXV0b2NvbXBsZXRlLW9wdGlvbnMtd3JhcHBlcmApIGFzIEhUTUxFbGVtZW50LFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRWaXNpYmxpdHkoXG4gICAgICAgICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYC5pbmZpbml0ZS1hdXRvY29tcGxldGUtb3B0aW9ucy13cmFwcGVyYCkgYXMgSFRNTEVsZW1lbnQsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgVXRpbHMudGhyb3dFcnJvckluQ29uc29sZShmZXRjaFNpemVFeGNlcHRpb25Nc2cpO1xuICAgIH1cbiAgfVxuXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9zcmMvQ29tcG9uZW50cy9JbmZpbml0ZUF1dG9jb21wbGV0ZS50cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQU9BO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBc0JBOzs7Ozs7OztBQVFBO0FBQ0E7QUFBQTtBQTFCQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFtQkE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOztBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkE7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFFQTtBQUlBO0FBQ0E7QUFvREE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1RUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTltQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBcWRBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFjQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTs7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7QUFDQTtBQUNBO0FBQ0E7O0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7Ozs7O0FBRUE7QUFxQkE7Ozs7QUFJQTtBQUNBO0FBQUE7Ozs7Ozs7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUlBO0FBQUE7QUFDQTtBQUlBOzs7QUFHQTs7Ozs7O0FBRUE7QUFFQTtBQUFBO0FBcnRCQTsiLCJzb3VyY2VSb290IjoiIn0=");

/***/ })
/******/ ]);
});